// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: embedded-windows.scheme.proto

#include "embedded-windows.scheme.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace SMBlob {
namespace EmbeddedWindows {
namespace Scheme {
PROTOBUF_CONSTEXPR Window::Window(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.windowuuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nativewindowid_)*/uint64_t{0u}
  , /*decltype(_impl_.windowid_)*/uint64_t{0u}
  , /*decltype(_impl_.processid_)*/uint64_t{0u}} {}
struct WindowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowDefaultTypeInternal() {}
  union {
    Window _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowDefaultTypeInternal _Window_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/uint64_t{0u}
  , /*decltype(_impl_.status_)*/0} {}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
PROTOBUF_CONSTEXPR CloseApplicationReq::CloseApplicationReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CloseApplicationReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseApplicationReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseApplicationReqDefaultTypeInternal() {}
  union {
    CloseApplicationReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseApplicationReqDefaultTypeInternal _CloseApplicationReq_default_instance_;
PROTOBUF_CONSTEXPR CloseApplicationRes::CloseApplicationRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr} {}
struct CloseApplicationResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseApplicationResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseApplicationResDefaultTypeInternal() {}
  union {
    CloseApplicationRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseApplicationResDefaultTypeInternal _CloseApplicationRes_default_instance_;
PROTOBUF_CONSTEXPR ConnectApplicationRes::ConnectApplicationRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr} {}
struct ConnectApplicationResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectApplicationResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectApplicationResDefaultTypeInternal() {}
  union {
    ConnectApplicationRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectApplicationResDefaultTypeInternal _ConnectApplicationRes_default_instance_;
PROTOBUF_CONSTEXPR InitApplicationRes::InitApplicationRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr} {}
struct InitApplicationResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitApplicationResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitApplicationResDefaultTypeInternal() {}
  union {
    InitApplicationRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitApplicationResDefaultTypeInternal _InitApplicationRes_default_instance_;
PROTOBUF_CONSTEXPR CloseWindowReq::CloseWindowReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.window_)*/nullptr} {}
struct CloseWindowReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseWindowReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseWindowReqDefaultTypeInternal() {}
  union {
    CloseWindowReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseWindowReqDefaultTypeInternal _CloseWindowReq_default_instance_;
PROTOBUF_CONSTEXPR CloseWindowRes::CloseWindowRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr} {}
struct CloseWindowResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseWindowResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseWindowResDefaultTypeInternal() {}
  union {
    CloseWindowRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseWindowResDefaultTypeInternal _CloseWindowRes_default_instance_;
PROTOBUF_CONSTEXPR EmbedWindowReq::EmbedWindowReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.window_)*/nullptr} {}
struct EmbedWindowReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedWindowReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedWindowReqDefaultTypeInternal() {}
  union {
    EmbedWindowReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedWindowReqDefaultTypeInternal _EmbedWindowReq_default_instance_;
PROTOBUF_CONSTEXPR EmbedWindowRes::EmbedWindowRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_.window_)*/nullptr
  , /*decltype(_impl_.parentwindow_)*/nullptr} {}
struct EmbedWindowResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedWindowResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedWindowResDefaultTypeInternal() {}
  union {
    EmbedWindowRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedWindowResDefaultTypeInternal _EmbedWindowRes_default_instance_;
PROTOBUF_CONSTEXPR ReleaseWindowReq::ReleaseWindowReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parentwindow_)*/nullptr} {}
struct ReleaseWindowReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReleaseWindowReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReleaseWindowReqDefaultTypeInternal() {}
  union {
    ReleaseWindowReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReleaseWindowReqDefaultTypeInternal _ReleaseWindowReq_default_instance_;
PROTOBUF_CONSTEXPR ReleaseWindowRes::ReleaseWindowRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_.parentwindow_)*/nullptr
  , /*decltype(_impl_.window_)*/nullptr} {}
struct ReleaseWindowResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReleaseWindowResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReleaseWindowResDefaultTypeInternal() {}
  union {
    ReleaseWindowRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReleaseWindowResDefaultTypeInternal _ReleaseWindowRes_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.Message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.Message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace Scheme
}  // namespace EmbeddedWindows
}  // namespace SMBlob
static ::_pb::Metadata file_level_metadata_embedded_2dwindows_2escheme_2eproto[14];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_embedded_2dwindows_2escheme_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_embedded_2dwindows_2escheme_2eproto = nullptr;

const uint32_t TableStruct_embedded_2dwindows_2escheme_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _impl_.nativewindowid_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _impl_.windowid_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _impl_.windowuuid_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Window, _impl_.processid_),
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Status, _impl_.time_),
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq, _impl_.tag_),
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _impl_.parentwindow_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes, _impl_.tag_),
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq, _impl_.parentwindow_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq, _impl_.tag_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _impl_.parentwindow_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes, _impl_.tag_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Request, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Request, _impl_.Message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Response, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SMBlob::EmbeddedWindows::Scheme::Response, _impl_.Message_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::Window)},
  { 14, 24, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::Status)},
  { 28, 35, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq)},
  { 36, 44, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes)},
  { 46, 54, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes)},
  { 56, 64, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes)},
  { 66, 74, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq)},
  { 76, 84, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes)},
  { 86, 94, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq)},
  { 96, 106, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes)},
  { 110, 118, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq)},
  { 120, 130, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes)},
  { 134, -1, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::Request)},
  { 145, -1, -1, sizeof(::SMBlob::EmbeddedWindows::Scheme::Response)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::SMBlob::EmbeddedWindows::Scheme::_Window_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_Status_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_CloseApplicationReq_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_CloseApplicationRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_ConnectApplicationRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_InitApplicationRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_CloseWindowReq_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_CloseWindowRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_EmbedWindowReq_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_EmbedWindowRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_ReleaseWindowReq_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_ReleaseWindowRes_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_Request_default_instance_._instance,
  &::SMBlob::EmbeddedWindows::Scheme::_Response_default_instance_._instance,
};

const char descriptor_table_protodef_embedded_2dwindows_2escheme_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035embedded-windows.scheme.proto\022\035SMBlob."
  "EmbeddedWindows.Scheme\"\200\001\n\006Window\022\026\n\016nat"
  "iveWindowId\030\001 \001(\004\022\020\n\010windowId\030\002 \001(\004\022\027\n\nw"
  "indowUuid\030\003 \001(\tH\000\210\001\001\022\026\n\tprocessId\030\004 \001(\004H"
  "\001\210\001\001B\r\n\013_windowUuidB\014\n\n_processId\"r\n\006Sta"
  "tus\022\016\n\006status\030\001 \001(\005\022\024\n\007message\030\002 \001(\tH\000\210\001"
  "\001\022\021\n\004code\030\003 \001(\tH\001\210\001\001\022\021\n\004time\030\004 \001(\004H\002\210\001\001B"
  "\n\n\010_messageB\007\n\005_codeB\007\n\005_time\"0\n\023CloseAp"
  "plicationReq\022\021\n\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\""
  "g\n\023CloseApplicationRes\0225\n\006status\030\001 \001(\0132%"
  ".SMBlob.EmbeddedWindows.Scheme.Status\022\021\n"
  "\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\"i\n\025ConnectAppli"
  "cationRes\0225\n\006status\030\001 \001(\0132%.SMBlob.Embed"
  "dedWindows.Scheme.Status\022\021\n\003tag\030\351\007 \001(\tH\000"
  "\210\001\001B\006\n\004_tag\"f\n\022InitApplicationRes\0225\n\006sta"
  "tus\030\001 \001(\0132%.SMBlob.EmbeddedWindows.Schem"
  "e.Status\022\021\n\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\"b\n\016C"
  "loseWindowReq\0225\n\006window\030\001 \001(\0132%.SMBlob.E"
  "mbeddedWindows.Scheme.Window\022\021\n\003tag\030\351\007 \001"
  "(\tH\000\210\001\001B\006\n\004_tag\"b\n\016CloseWindowRes\0225\n\006sta"
  "tus\030\001 \001(\0132%.SMBlob.EmbeddedWindows.Schem"
  "e.Status\022\021\n\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\"b\n\016E"
  "mbedWindowReq\0225\n\006window\030\001 \001(\0132%.SMBlob.E"
  "mbeddedWindows.Scheme.Window\022\021\n\003tag\030\351\007 \001"
  "(\tH\000\210\001\001B\006\n\004_tag\"\326\001\n\016EmbedWindowRes\0225\n\006st"
  "atus\030\001 \001(\0132%.SMBlob.EmbeddedWindows.Sche"
  "me.Status\0225\n\006window\030\002 \001(\0132%.SMBlob.Embed"
  "dedWindows.Scheme.Window\022;\n\014parentWindow"
  "\030\003 \001(\0132%.SMBlob.EmbeddedWindows.Scheme.W"
  "indow\022\021\n\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\"j\n\020Rele"
  "aseWindowReq\022;\n\014parentWindow\030\001 \001(\0132%.SMB"
  "lob.EmbeddedWindows.Scheme.Window\022\021\n\003tag"
  "\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\"\330\001\n\020ReleaseWindowRe"
  "s\0225\n\006status\030\001 \001(\0132%.SMBlob.EmbeddedWindo"
  "ws.Scheme.Status\022;\n\014parentWindow\030\002 \001(\0132%"
  ".SMBlob.EmbeddedWindows.Scheme.Window\0225\n"
  "\006window\030\003 \001(\0132%.SMBlob.EmbeddedWindows.S"
  "cheme.Window\022\021\n\003tag\030\351\007 \001(\tH\000\210\001\001B\006\n\004_tag\""
  "\272\002\n\007Request\022N\n\020closeApplication\030\001 \001(\01322."
  "SMBlob.EmbeddedWindows.Scheme.CloseAppli"
  "cationReqH\000\022D\n\013embedWindow\030\002 \001(\0132-.SMBlo"
  "b.EmbeddedWindows.Scheme.EmbedWindowReqH"
  "\000\022H\n\rreleaseWindow\030\003 \001(\0132/.SMBlob.Embedd"
  "edWindows.Scheme.ReleaseWindowReqH\000\022D\n\013c"
  "loseWindow\030\004 \001(\0132-.SMBlob.EmbeddedWindow"
  "s.Scheme.CloseWindowReqH\000B\t\n\007Message\"\335\003\n"
  "\010Response\022N\n\020closeApplication\030\001 \001(\01322.SM"
  "Blob.EmbeddedWindows.Scheme.CloseApplica"
  "tionResH\000\022D\n\013embedWindow\030\002 \001(\0132-.SMBlob."
  "EmbeddedWindows.Scheme.EmbedWindowResH\000\022"
  "H\n\rreleaseWindow\030\003 \001(\0132/.SMBlob.Embedded"
  "Windows.Scheme.ReleaseWindowResH\000\022D\n\013clo"
  "seWindow\030\004 \001(\0132-.SMBlob.EmbeddedWindows."
  "Scheme.CloseWindowResH\000\022R\n\022connectApplic"
  "ation\030\005 \001(\01324.SMBlob.EmbeddedWindows.Sch"
  "eme.ConnectApplicationResH\000\022L\n\017initAppli"
  "cation\030\006 \001(\01321.SMBlob.EmbeddedWindows.Sc"
  "heme.InitApplicationResH\000B\t\n\007Messageb\006pr"
  "oto3"
  ;
static ::_pbi::once_flag descriptor_table_embedded_2dwindows_2escheme_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_embedded_2dwindows_2escheme_2eproto = {
    false, false, 2324, descriptor_table_protodef_embedded_2dwindows_2escheme_2eproto,
    "embedded-windows.scheme.proto",
    &descriptor_table_embedded_2dwindows_2escheme_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_embedded_2dwindows_2escheme_2eproto::offsets,
    file_level_metadata_embedded_2dwindows_2escheme_2eproto, file_level_enum_descriptors_embedded_2dwindows_2escheme_2eproto,
    file_level_service_descriptors_embedded_2dwindows_2escheme_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_embedded_2dwindows_2escheme_2eproto_getter() {
  return &descriptor_table_embedded_2dwindows_2escheme_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_embedded_2dwindows_2escheme_2eproto(&descriptor_table_embedded_2dwindows_2escheme_2eproto);
namespace SMBlob {
namespace EmbeddedWindows {
namespace Scheme {

// ===================================================================

class Window::_Internal {
 public:
  using HasBits = decltype(std::declval<Window>()._impl_._has_bits_);
  static void set_has_windowuuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_processid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Window::Window(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.Window)
}
Window::Window(const Window& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Window* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.windowuuid_){}
    , decltype(_impl_.nativewindowid_){}
    , decltype(_impl_.windowid_){}
    , decltype(_impl_.processid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.windowuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.windowuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_windowuuid()) {
    _this->_impl_.windowuuid_.Set(from._internal_windowuuid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nativewindowid_, &from._impl_.nativewindowid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.processid_) -
    reinterpret_cast<char*>(&_impl_.nativewindowid_)) + sizeof(_impl_.processid_));
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.Window)
}

inline void Window::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.windowuuid_){}
    , decltype(_impl_.nativewindowid_){uint64_t{0u}}
    , decltype(_impl_.windowid_){uint64_t{0u}}
    , decltype(_impl_.processid_){uint64_t{0u}}
  };
  _impl_.windowuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.windowuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Window::~Window() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.Window)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Window::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.windowuuid_.Destroy();
}

void Window::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Window::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.Window)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.windowuuid_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.nativewindowid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.windowid_) -
      reinterpret_cast<char*>(&_impl_.nativewindowid_)) + sizeof(_impl_.windowid_));
  _impl_.processid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Window::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nativeWindowId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nativewindowid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 windowId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.windowid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string windowUuid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_windowuuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.Window.windowUuid"));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 processId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_processid(&has_bits);
          _impl_.processid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Window::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.Window)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nativeWindowId = 1;
  if (this->_internal_nativewindowid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nativewindowid(), target);
  }

  // uint64 windowId = 2;
  if (this->_internal_windowid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_windowid(), target);
  }

  // optional string windowUuid = 3;
  if (_internal_has_windowuuid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_windowuuid().data(), static_cast<int>(this->_internal_windowuuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.Window.windowUuid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_windowuuid(), target);
  }

  // optional uint64 processId = 4;
  if (_internal_has_processid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_processid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.Window)
  return target;
}

size_t Window::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.Window)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string windowUuid = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_windowuuid());
  }

  // uint64 nativeWindowId = 1;
  if (this->_internal_nativewindowid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nativewindowid());
  }

  // uint64 windowId = 2;
  if (this->_internal_windowid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_windowid());
  }

  // optional uint64 processId = 4;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_processid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Window::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Window::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Window::GetClassData() const { return &_class_data_; }


void Window::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Window*>(&to_msg);
  auto& from = static_cast<const Window&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.Window)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_windowuuid()) {
    _this->_internal_set_windowuuid(from._internal_windowuuid());
  }
  if (from._internal_nativewindowid() != 0) {
    _this->_internal_set_nativewindowid(from._internal_nativewindowid());
  }
  if (from._internal_windowid() != 0) {
    _this->_internal_set_windowid(from._internal_windowid());
  }
  if (from._internal_has_processid()) {
    _this->_internal_set_processid(from._internal_processid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Window::CopyFrom(const Window& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.Window)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Window::IsInitialized() const {
  return true;
}

void Window::InternalSwap(Window* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.windowuuid_, lhs_arena,
      &other->_impl_.windowuuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Window, _impl_.processid_)
      + sizeof(Window::_impl_.processid_)
      - PROTOBUF_FIELD_OFFSET(Window, _impl_.nativewindowid_)>(
          reinterpret_cast<char*>(&_impl_.nativewindowid_),
          reinterpret_cast<char*>(&other->_impl_.nativewindowid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Window::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[0]);
}

// ===================================================================

class Status::_Internal {
 public:
  using HasBits = decltype(std::declval<Status>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Status* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.code_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    _this->_impl_.code_.Set(from._internal_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.Status)
}

inline void Status::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.code_){}
    , decltype(_impl_.time_){uint64_t{0u}}
    , decltype(_impl_.status_){0}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.code_.Destroy();
}

void Status::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.code_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.time_ = uint64_t{0u};
  _impl_.status_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.Status.message"));
        } else
          goto handle_unusual;
        continue;
      // optional string code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.Status.code"));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  // optional string message = 2;
  if (_internal_has_message()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.Status.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional string code = 3;
  if (_internal_has_code()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_code().data(), static_cast<int>(this->_internal_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.Status.code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_code(), target);
  }

  // optional uint64 time = 4;
  if (_internal_has_time()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional string code = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional uint64 time = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_time());
    }

  }
  // int32 status = 1;
  if (this->_internal_status() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Status::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Status::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Status::GetClassData() const { return &_class_data_; }


void Status::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Status*>(&to_msg);
  auto& from = static_cast<const Status&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.Status)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.code_, lhs_arena,
      &other->_impl_.code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, _impl_.status_)
      + sizeof(Status::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Status, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[1]);
}

// ===================================================================

class CloseApplicationReq::_Internal {
 public:
  using HasBits = decltype(std::declval<CloseApplicationReq>()._impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CloseApplicationReq::CloseApplicationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
}
CloseApplicationReq::CloseApplicationReq(const CloseApplicationReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CloseApplicationReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
}

inline void CloseApplicationReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CloseApplicationReq::~CloseApplicationReq() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseApplicationReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
}

void CloseApplicationReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CloseApplicationReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseApplicationReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseApplicationReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  return target;
}

size_t CloseApplicationReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseApplicationReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CloseApplicationReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseApplicationReq::GetClassData() const { return &_class_data_; }


void CloseApplicationReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CloseApplicationReq*>(&to_msg);
  auto& from = static_cast<const CloseApplicationReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseApplicationReq::CopyFrom(const CloseApplicationReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseApplicationReq::IsInitialized() const {
  return true;
}

void CloseApplicationReq::InternalSwap(CloseApplicationReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseApplicationReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[2]);
}

// ===================================================================

class CloseApplicationRes::_Internal {
 public:
  using HasBits = decltype(std::declval<CloseApplicationRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const CloseApplicationRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
CloseApplicationRes::_Internal::status(const CloseApplicationRes* msg) {
  return *msg->_impl_.status_;
}
CloseApplicationRes::CloseApplicationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
}
CloseApplicationRes::CloseApplicationRes(const CloseApplicationRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CloseApplicationRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
}

inline void CloseApplicationRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CloseApplicationRes::~CloseApplicationRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseApplicationRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
}

void CloseApplicationRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CloseApplicationRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseApplicationRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseApplicationRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  return target;
}

size_t CloseApplicationRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseApplicationRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CloseApplicationRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseApplicationRes::GetClassData() const { return &_class_data_; }


void CloseApplicationRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CloseApplicationRes*>(&to_msg);
  auto& from = static_cast<const CloseApplicationRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseApplicationRes::CopyFrom(const CloseApplicationRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseApplicationRes::IsInitialized() const {
  return true;
}

void CloseApplicationRes::InternalSwap(CloseApplicationRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseApplicationRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[3]);
}

// ===================================================================

class ConnectApplicationRes::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectApplicationRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const ConnectApplicationRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
ConnectApplicationRes::_Internal::status(const ConnectApplicationRes* msg) {
  return *msg->_impl_.status_;
}
ConnectApplicationRes::ConnectApplicationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
}
ConnectApplicationRes::ConnectApplicationRes(const ConnectApplicationRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectApplicationRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
}

inline void ConnectApplicationRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectApplicationRes::~ConnectApplicationRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectApplicationRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
}

void ConnectApplicationRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectApplicationRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectApplicationRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectApplicationRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  return target;
}

size_t ConnectApplicationRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectApplicationRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectApplicationRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectApplicationRes::GetClassData() const { return &_class_data_; }


void ConnectApplicationRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectApplicationRes*>(&to_msg);
  auto& from = static_cast<const ConnectApplicationRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectApplicationRes::CopyFrom(const ConnectApplicationRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectApplicationRes::IsInitialized() const {
  return true;
}

void ConnectApplicationRes::InternalSwap(ConnectApplicationRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectApplicationRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[4]);
}

// ===================================================================

class InitApplicationRes::_Internal {
 public:
  using HasBits = decltype(std::declval<InitApplicationRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const InitApplicationRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
InitApplicationRes::_Internal::status(const InitApplicationRes* msg) {
  return *msg->_impl_.status_;
}
InitApplicationRes::InitApplicationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
}
InitApplicationRes::InitApplicationRes(const InitApplicationRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InitApplicationRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
}

inline void InitApplicationRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InitApplicationRes::~InitApplicationRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InitApplicationRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
}

void InitApplicationRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InitApplicationRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitApplicationRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.InitApplicationRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitApplicationRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.InitApplicationRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  return target;
}

size_t InitApplicationRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitApplicationRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InitApplicationRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitApplicationRes::GetClassData() const { return &_class_data_; }


void InitApplicationRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InitApplicationRes*>(&to_msg);
  auto& from = static_cast<const InitApplicationRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitApplicationRes::CopyFrom(const InitApplicationRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.InitApplicationRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitApplicationRes::IsInitialized() const {
  return true;
}

void InitApplicationRes::InternalSwap(InitApplicationRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InitApplicationRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[5]);
}

// ===================================================================

class CloseWindowReq::_Internal {
 public:
  using HasBits = decltype(std::declval<CloseWindowReq>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& window(const CloseWindowReq* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Window&
CloseWindowReq::_Internal::window(const CloseWindowReq* msg) {
  return *msg->_impl_.window_;
}
CloseWindowReq::CloseWindowReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
}
CloseWindowReq::CloseWindowReq(const CloseWindowReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CloseWindowReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.window_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_window()) {
    _this->_impl_.window_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.window_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
}

inline void CloseWindowReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.window_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CloseWindowReq::~CloseWindowReq() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseWindowReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.window_;
}

void CloseWindowReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CloseWindowReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.window_ != nullptr) {
    delete _impl_.window_;
  }
  _impl_.window_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseWindowReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_window(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.CloseWindowReq.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseWindowReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
  if (this->_internal_has_window()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::window(this),
        _Internal::window(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.CloseWindowReq.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  return target;
}

size_t CloseWindowReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
  if (this->_internal_has_window()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.window_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseWindowReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CloseWindowReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseWindowReq::GetClassData() const { return &_class_data_; }


void CloseWindowReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CloseWindowReq*>(&to_msg);
  auto& from = static_cast<const CloseWindowReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_window()) {
    _this->_internal_mutable_window()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_window());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseWindowReq::CopyFrom(const CloseWindowReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseWindowReq::IsInitialized() const {
  return true;
}

void CloseWindowReq::InternalSwap(CloseWindowReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.window_, other->_impl_.window_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseWindowReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[6]);
}

// ===================================================================

class CloseWindowRes::_Internal {
 public:
  using HasBits = decltype(std::declval<CloseWindowRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const CloseWindowRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
CloseWindowRes::_Internal::status(const CloseWindowRes* msg) {
  return *msg->_impl_.status_;
}
CloseWindowRes::CloseWindowRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
}
CloseWindowRes::CloseWindowRes(const CloseWindowRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CloseWindowRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
}

inline void CloseWindowRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CloseWindowRes::~CloseWindowRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseWindowRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
}

void CloseWindowRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CloseWindowRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseWindowRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.CloseWindowRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseWindowRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.CloseWindowRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  return target;
}

size_t CloseWindowRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseWindowRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CloseWindowRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseWindowRes::GetClassData() const { return &_class_data_; }


void CloseWindowRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CloseWindowRes*>(&to_msg);
  auto& from = static_cast<const CloseWindowRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseWindowRes::CopyFrom(const CloseWindowRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.CloseWindowRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseWindowRes::IsInitialized() const {
  return true;
}

void CloseWindowRes::InternalSwap(CloseWindowRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseWindowRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[7]);
}

// ===================================================================

class EmbedWindowReq::_Internal {
 public:
  using HasBits = decltype(std::declval<EmbedWindowReq>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& window(const EmbedWindowReq* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Window&
EmbedWindowReq::_Internal::window(const EmbedWindowReq* msg) {
  return *msg->_impl_.window_;
}
EmbedWindowReq::EmbedWindowReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
}
EmbedWindowReq::EmbedWindowReq(const EmbedWindowReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmbedWindowReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.window_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_window()) {
    _this->_impl_.window_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.window_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
}

inline void EmbedWindowReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.window_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EmbedWindowReq::~EmbedWindowReq() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedWindowReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.window_;
}

void EmbedWindowReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedWindowReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.window_ != nullptr) {
    delete _impl_.window_;
  }
  _impl_.window_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedWindowReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_window(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbedWindowReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
  if (this->_internal_has_window()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::window(this),
        _Internal::window(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  return target;
}

size_t EmbedWindowReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 1;
  if (this->_internal_has_window()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.window_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedWindowReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedWindowReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedWindowReq::GetClassData() const { return &_class_data_; }


void EmbedWindowReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedWindowReq*>(&to_msg);
  auto& from = static_cast<const EmbedWindowReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_window()) {
    _this->_internal_mutable_window()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_window());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedWindowReq::CopyFrom(const EmbedWindowReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedWindowReq::IsInitialized() const {
  return true;
}

void EmbedWindowReq::InternalSwap(EmbedWindowReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.window_, other->_impl_.window_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedWindowReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[8]);
}

// ===================================================================

class EmbedWindowRes::_Internal {
 public:
  using HasBits = decltype(std::declval<EmbedWindowRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const EmbedWindowRes* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& window(const EmbedWindowRes* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& parentwindow(const EmbedWindowRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
EmbedWindowRes::_Internal::status(const EmbedWindowRes* msg) {
  return *msg->_impl_.status_;
}
const ::SMBlob::EmbeddedWindows::Scheme::Window&
EmbedWindowRes::_Internal::window(const EmbedWindowRes* msg) {
  return *msg->_impl_.window_;
}
const ::SMBlob::EmbeddedWindows::Scheme::Window&
EmbedWindowRes::_Internal::parentwindow(const EmbedWindowRes* msg) {
  return *msg->_impl_.parentwindow_;
}
EmbedWindowRes::EmbedWindowRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
}
EmbedWindowRes::EmbedWindowRes(const EmbedWindowRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmbedWindowRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
    , decltype(_impl_.window_){nullptr}
    , decltype(_impl_.parentwindow_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  if (from._internal_has_window()) {
    _this->_impl_.window_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.window_);
  }
  if (from._internal_has_parentwindow()) {
    _this->_impl_.parentwindow_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.parentwindow_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
}

inline void EmbedWindowRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
    , decltype(_impl_.window_){nullptr}
    , decltype(_impl_.parentwindow_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EmbedWindowRes::~EmbedWindowRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedWindowRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
  if (this != internal_default_instance()) delete _impl_.window_;
  if (this != internal_default_instance()) delete _impl_.parentwindow_;
}

void EmbedWindowRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedWindowRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.window_ != nullptr) {
    delete _impl_.window_;
  }
  _impl_.window_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.parentwindow_ != nullptr) {
    delete _impl_.parentwindow_;
  }
  _impl_.parentwindow_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedWindowRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.Window window = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_window(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parentwindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbedWindowRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 2;
  if (this->_internal_has_window()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::window(this),
        _Internal::window(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 3;
  if (this->_internal_has_parentwindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parentwindow(this),
        _Internal::parentwindow(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  return target;
}

size_t EmbedWindowRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 2;
  if (this->_internal_has_window()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.window_);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 3;
  if (this->_internal_has_parentwindow()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parentwindow_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedWindowRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedWindowRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedWindowRes::GetClassData() const { return &_class_data_; }


void EmbedWindowRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedWindowRes*>(&to_msg);
  auto& from = static_cast<const EmbedWindowRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  if (from._internal_has_window()) {
    _this->_internal_mutable_window()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_window());
  }
  if (from._internal_has_parentwindow()) {
    _this->_internal_mutable_parentwindow()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_parentwindow());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedWindowRes::CopyFrom(const EmbedWindowRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedWindowRes::IsInitialized() const {
  return true;
}

void EmbedWindowRes::InternalSwap(EmbedWindowRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmbedWindowRes, _impl_.parentwindow_)
      + sizeof(EmbedWindowRes::_impl_.parentwindow_)
      - PROTOBUF_FIELD_OFFSET(EmbedWindowRes, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedWindowRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[9]);
}

// ===================================================================

class ReleaseWindowReq::_Internal {
 public:
  using HasBits = decltype(std::declval<ReleaseWindowReq>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& parentwindow(const ReleaseWindowReq* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Window&
ReleaseWindowReq::_Internal::parentwindow(const ReleaseWindowReq* msg) {
  return *msg->_impl_.parentwindow_;
}
ReleaseWindowReq::ReleaseWindowReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
}
ReleaseWindowReq::ReleaseWindowReq(const ReleaseWindowReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReleaseWindowReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.parentwindow_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_parentwindow()) {
    _this->_impl_.parentwindow_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.parentwindow_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
}

inline void ReleaseWindowReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.parentwindow_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReleaseWindowReq::~ReleaseWindowReq() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReleaseWindowReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.parentwindow_;
}

void ReleaseWindowReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReleaseWindowReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.parentwindow_ != nullptr) {
    delete _impl_.parentwindow_;
  }
  _impl_.parentwindow_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReleaseWindowReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_parentwindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReleaseWindowReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 1;
  if (this->_internal_has_parentwindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::parentwindow(this),
        _Internal::parentwindow(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  return target;
}

size_t ReleaseWindowReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 1;
  if (this->_internal_has_parentwindow()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parentwindow_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReleaseWindowReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReleaseWindowReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReleaseWindowReq::GetClassData() const { return &_class_data_; }


void ReleaseWindowReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReleaseWindowReq*>(&to_msg);
  auto& from = static_cast<const ReleaseWindowReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_parentwindow()) {
    _this->_internal_mutable_parentwindow()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_parentwindow());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReleaseWindowReq::CopyFrom(const ReleaseWindowReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReleaseWindowReq::IsInitialized() const {
  return true;
}

void ReleaseWindowReq::InternalSwap(ReleaseWindowReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  swap(_impl_.parentwindow_, other->_impl_.parentwindow_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReleaseWindowReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[10]);
}

// ===================================================================

class ReleaseWindowRes::_Internal {
 public:
  using HasBits = decltype(std::declval<ReleaseWindowRes>()._impl_._has_bits_);
  static const ::SMBlob::EmbeddedWindows::Scheme::Status& status(const ReleaseWindowRes* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& parentwindow(const ReleaseWindowRes* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::Window& window(const ReleaseWindowRes* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SMBlob::EmbeddedWindows::Scheme::Status&
ReleaseWindowRes::_Internal::status(const ReleaseWindowRes* msg) {
  return *msg->_impl_.status_;
}
const ::SMBlob::EmbeddedWindows::Scheme::Window&
ReleaseWindowRes::_Internal::parentwindow(const ReleaseWindowRes* msg) {
  return *msg->_impl_.parentwindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::Window&
ReleaseWindowRes::_Internal::window(const ReleaseWindowRes* msg) {
  return *msg->_impl_.window_;
}
ReleaseWindowRes::ReleaseWindowRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
}
ReleaseWindowRes::ReleaseWindowRes(const ReleaseWindowRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReleaseWindowRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
    , decltype(_impl_.parentwindow_){nullptr}
    , decltype(_impl_.window_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::SMBlob::EmbeddedWindows::Scheme::Status(*from._impl_.status_);
  }
  if (from._internal_has_parentwindow()) {
    _this->_impl_.parentwindow_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.parentwindow_);
  }
  if (from._internal_has_window()) {
    _this->_impl_.window_ = new ::SMBlob::EmbeddedWindows::Scheme::Window(*from._impl_.window_);
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
}

inline void ReleaseWindowRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.status_){nullptr}
    , decltype(_impl_.parentwindow_){nullptr}
    , decltype(_impl_.window_){nullptr}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReleaseWindowRes::~ReleaseWindowRes() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReleaseWindowRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.status_;
  if (this != internal_default_instance()) delete _impl_.parentwindow_;
  if (this != internal_default_instance()) delete _impl_.window_;
}

void ReleaseWindowRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReleaseWindowRes::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.parentwindow_ != nullptr) {
    delete _impl_.parentwindow_;
  }
  _impl_.parentwindow_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.window_ != nullptr) {
    delete _impl_.window_;
  }
  _impl_.window_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReleaseWindowRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parentwindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.Window window = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_window(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 1001;
      case 1001:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes.tag"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReleaseWindowRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 2;
  if (this->_internal_has_parentwindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parentwindow(this),
        _Internal::parentwindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 3;
  if (this->_internal_has_window()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::window(this),
        _Internal::window(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 1001;
  if (_internal_has_tag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes.tag");
    target = stream->WriteStringMaybeAliased(
        1001, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  return target;
}

size_t ReleaseWindowRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tag = 1001;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .SMBlob.EmbeddedWindows.Scheme.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window parentWindow = 2;
  if (this->_internal_has_parentwindow()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parentwindow_);
  }

  // .SMBlob.EmbeddedWindows.Scheme.Window window = 3;
  if (this->_internal_has_window()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.window_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReleaseWindowRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReleaseWindowRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReleaseWindowRes::GetClassData() const { return &_class_data_; }


void ReleaseWindowRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReleaseWindowRes*>(&to_msg);
  auto& from = static_cast<const ReleaseWindowRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::SMBlob::EmbeddedWindows::Scheme::Status::MergeFrom(
        from._internal_status());
  }
  if (from._internal_has_parentwindow()) {
    _this->_internal_mutable_parentwindow()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_parentwindow());
  }
  if (from._internal_has_window()) {
    _this->_internal_mutable_window()->::SMBlob::EmbeddedWindows::Scheme::Window::MergeFrom(
        from._internal_window());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReleaseWindowRes::CopyFrom(const ReleaseWindowRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReleaseWindowRes::IsInitialized() const {
  return true;
}

void ReleaseWindowRes::InternalSwap(ReleaseWindowRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReleaseWindowRes, _impl_.window_)
      + sizeof(ReleaseWindowRes::_impl_.window_)
      - PROTOBUF_FIELD_OFFSET(ReleaseWindowRes, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReleaseWindowRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[11]);
}

// ===================================================================

class Request::_Internal {
 public:
  static const ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq& closeapplication(const Request* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq& embedwindow(const Request* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq& releasewindow(const Request* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq& closewindow(const Request* msg);
};

const ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq&
Request::_Internal::closeapplication(const Request* msg) {
  return *msg->_impl_.Message_.closeapplication_;
}
const ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq&
Request::_Internal::embedwindow(const Request* msg) {
  return *msg->_impl_.Message_.embedwindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq&
Request::_Internal::releasewindow(const Request* msg) {
  return *msg->_impl_.Message_.releasewindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq&
Request::_Internal::closewindow(const Request* msg) {
  return *msg->_impl_.Message_.closewindow_;
}
void Request::set_allocated_closeapplication(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq* closeapplication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (closeapplication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closeapplication);
    if (message_arena != submessage_arena) {
      closeapplication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closeapplication, submessage_arena);
    }
    set_has_closeapplication();
    _impl_.Message_.closeapplication_ = closeapplication;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Request.closeApplication)
}
void Request::set_allocated_embedwindow(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq* embedwindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (embedwindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(embedwindow);
    if (message_arena != submessage_arena) {
      embedwindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embedwindow, submessage_arena);
    }
    set_has_embedwindow();
    _impl_.Message_.embedwindow_ = embedwindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Request.embedWindow)
}
void Request::set_allocated_releasewindow(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq* releasewindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (releasewindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(releasewindow);
    if (message_arena != submessage_arena) {
      releasewindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, releasewindow, submessage_arena);
    }
    set_has_releasewindow();
    _impl_.Message_.releasewindow_ = releasewindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Request.releaseWindow)
}
void Request::set_allocated_closewindow(::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq* closewindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (closewindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closewindow);
    if (message_arena != submessage_arena) {
      closewindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closewindow, submessage_arena);
    }
    set_has_closewindow();
    _impl_.Message_.closewindow_ = closewindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Request.closeWindow)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.Message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_Message();
  switch (from.Message_case()) {
    case kCloseApplication: {
      _this->_internal_mutable_closeapplication()->::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq::MergeFrom(
          from._internal_closeapplication());
      break;
    }
    case kEmbedWindow: {
      _this->_internal_mutable_embedwindow()->::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq::MergeFrom(
          from._internal_embedwindow());
      break;
    }
    case kReleaseWindow: {
      _this->_internal_mutable_releasewindow()->::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq::MergeFrom(
          from._internal_releasewindow());
      break;
    }
    case kCloseWindow: {
      _this->_internal_mutable_closewindow()->::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq::MergeFrom(
          from._internal_closewindow());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.Message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Message();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Message()) {
    clear_Message();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_Message() {
// @@protoc_insertion_point(one_of_clear_start:SMBlob.EmbeddedWindows.Scheme.Request)
  switch (Message_case()) {
    case kCloseApplication: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.closeapplication_;
      }
      break;
    }
    case kEmbedWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.embedwindow_;
      }
      break;
    }
    case kReleaseWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.releasewindow_;
      }
      break;
    }
    case kCloseWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.closewindow_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq closeApplication = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_closeapplication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq embedWindow = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_embedwindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq releaseWindow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_releasewindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.CloseWindowReq closeWindow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_closewindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq closeApplication = 1;
  if (_internal_has_closeapplication()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::closeapplication(this),
        _Internal::closeapplication(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq embedWindow = 2;
  if (_internal_has_embedwindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::embedwindow(this),
        _Internal::embedwindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq releaseWindow = 3;
  if (_internal_has_releasewindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::releasewindow(this),
        _Internal::releasewindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.CloseWindowReq closeWindow = 4;
  if (_internal_has_closewindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::closewindow(this),
        _Internal::closewindow(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Message_case()) {
    // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationReq closeApplication = 1;
    case kCloseApplication: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.closeapplication_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowReq embedWindow = 2;
    case kEmbedWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.embedwindow_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowReq releaseWindow = 3;
    case kReleaseWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.releasewindow_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.CloseWindowReq closeWindow = 4;
    case kCloseWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.closewindow_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Message_case()) {
    case kCloseApplication: {
      _this->_internal_mutable_closeapplication()->::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq::MergeFrom(
          from._internal_closeapplication());
      break;
    }
    case kEmbedWindow: {
      _this->_internal_mutable_embedwindow()->::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq::MergeFrom(
          from._internal_embedwindow());
      break;
    }
    case kReleaseWindow: {
      _this->_internal_mutable_releasewindow()->::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq::MergeFrom(
          from._internal_releasewindow());
      break;
    }
    case kCloseWindow: {
      _this->_internal_mutable_closewindow()->::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq::MergeFrom(
          from._internal_closewindow());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.Message_, other->_impl_.Message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[12]);
}

// ===================================================================

class Response::_Internal {
 public:
  static const ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes& closeapplication(const Response* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes& embedwindow(const Response* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes& releasewindow(const Response* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes& closewindow(const Response* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes& connectapplication(const Response* msg);
  static const ::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes& initapplication(const Response* msg);
};

const ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes&
Response::_Internal::closeapplication(const Response* msg) {
  return *msg->_impl_.Message_.closeapplication_;
}
const ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes&
Response::_Internal::embedwindow(const Response* msg) {
  return *msg->_impl_.Message_.embedwindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes&
Response::_Internal::releasewindow(const Response* msg) {
  return *msg->_impl_.Message_.releasewindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes&
Response::_Internal::closewindow(const Response* msg) {
  return *msg->_impl_.Message_.closewindow_;
}
const ::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes&
Response::_Internal::connectapplication(const Response* msg) {
  return *msg->_impl_.Message_.connectapplication_;
}
const ::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes&
Response::_Internal::initapplication(const Response* msg) {
  return *msg->_impl_.Message_.initapplication_;
}
void Response::set_allocated_closeapplication(::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes* closeapplication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (closeapplication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closeapplication);
    if (message_arena != submessage_arena) {
      closeapplication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closeapplication, submessage_arena);
    }
    set_has_closeapplication();
    _impl_.Message_.closeapplication_ = closeapplication;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.closeApplication)
}
void Response::set_allocated_embedwindow(::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes* embedwindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (embedwindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(embedwindow);
    if (message_arena != submessage_arena) {
      embedwindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embedwindow, submessage_arena);
    }
    set_has_embedwindow();
    _impl_.Message_.embedwindow_ = embedwindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.embedWindow)
}
void Response::set_allocated_releasewindow(::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes* releasewindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (releasewindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(releasewindow);
    if (message_arena != submessage_arena) {
      releasewindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, releasewindow, submessage_arena);
    }
    set_has_releasewindow();
    _impl_.Message_.releasewindow_ = releasewindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.releaseWindow)
}
void Response::set_allocated_closewindow(::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes* closewindow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (closewindow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closewindow);
    if (message_arena != submessage_arena) {
      closewindow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closewindow, submessage_arena);
    }
    set_has_closewindow();
    _impl_.Message_.closewindow_ = closewindow;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.closeWindow)
}
void Response::set_allocated_connectapplication(::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes* connectapplication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (connectapplication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connectapplication);
    if (message_arena != submessage_arena) {
      connectapplication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connectapplication, submessage_arena);
    }
    set_has_connectapplication();
    _impl_.Message_.connectapplication_ = connectapplication;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.connectApplication)
}
void Response::set_allocated_initapplication(::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes* initapplication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Message();
  if (initapplication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initapplication);
    if (message_arena != submessage_arena) {
      initapplication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initapplication, submessage_arena);
    }
    set_has_initapplication();
    _impl_.Message_.initapplication_ = initapplication;
  }
  // @@protoc_insertion_point(field_set_allocated:SMBlob.EmbeddedWindows.Scheme.Response.initApplication)
}
Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SMBlob.EmbeddedWindows.Scheme.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.Message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_Message();
  switch (from.Message_case()) {
    case kCloseApplication: {
      _this->_internal_mutable_closeapplication()->::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes::MergeFrom(
          from._internal_closeapplication());
      break;
    }
    case kEmbedWindow: {
      _this->_internal_mutable_embedwindow()->::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes::MergeFrom(
          from._internal_embedwindow());
      break;
    }
    case kReleaseWindow: {
      _this->_internal_mutable_releasewindow()->::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes::MergeFrom(
          from._internal_releasewindow());
      break;
    }
    case kCloseWindow: {
      _this->_internal_mutable_closewindow()->::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes::MergeFrom(
          from._internal_closewindow());
      break;
    }
    case kConnectApplication: {
      _this->_internal_mutable_connectapplication()->::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes::MergeFrom(
          from._internal_connectapplication());
      break;
    }
    case kInitApplication: {
      _this->_internal_mutable_initapplication()->::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes::MergeFrom(
          from._internal_initapplication());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SMBlob.EmbeddedWindows.Scheme.Response)
}

inline void Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.Message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Message();
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:SMBlob.EmbeddedWindows.Scheme.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Message()) {
    clear_Message();
  }
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::clear_Message() {
// @@protoc_insertion_point(one_of_clear_start:SMBlob.EmbeddedWindows.Scheme.Response)
  switch (Message_case()) {
    case kCloseApplication: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.closeapplication_;
      }
      break;
    }
    case kEmbedWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.embedwindow_;
      }
      break;
    }
    case kReleaseWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.releasewindow_;
      }
      break;
    }
    case kCloseWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.closewindow_;
      }
      break;
    }
    case kConnectApplication: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.connectapplication_;
      }
      break;
    }
    case kInitApplication: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Message_.initapplication_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:SMBlob.EmbeddedWindows.Scheme.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes closeApplication = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_closeapplication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes embedWindow = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_embedwindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes releaseWindow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_releasewindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.CloseWindowRes closeWindow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_closewindow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes connectApplication = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_connectapplication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SMBlob.EmbeddedWindows.Scheme.InitApplicationRes initApplication = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_initapplication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SMBlob.EmbeddedWindows.Scheme.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes closeApplication = 1;
  if (_internal_has_closeapplication()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::closeapplication(this),
        _Internal::closeapplication(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes embedWindow = 2;
  if (_internal_has_embedwindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::embedwindow(this),
        _Internal::embedwindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes releaseWindow = 3;
  if (_internal_has_releasewindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::releasewindow(this),
        _Internal::releasewindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.CloseWindowRes closeWindow = 4;
  if (_internal_has_closewindow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::closewindow(this),
        _Internal::closewindow(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes connectApplication = 5;
  if (_internal_has_connectapplication()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::connectapplication(this),
        _Internal::connectapplication(this).GetCachedSize(), target, stream);
  }

  // .SMBlob.EmbeddedWindows.Scheme.InitApplicationRes initApplication = 6;
  if (_internal_has_initapplication()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::initapplication(this),
        _Internal::initapplication(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SMBlob.EmbeddedWindows.Scheme.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SMBlob.EmbeddedWindows.Scheme.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Message_case()) {
    // .SMBlob.EmbeddedWindows.Scheme.CloseApplicationRes closeApplication = 1;
    case kCloseApplication: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.closeapplication_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.EmbedWindowRes embedWindow = 2;
    case kEmbedWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.embedwindow_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.ReleaseWindowRes releaseWindow = 3;
    case kReleaseWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.releasewindow_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.CloseWindowRes closeWindow = 4;
    case kCloseWindow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.closewindow_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.ConnectApplicationRes connectApplication = 5;
    case kConnectApplication: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.connectapplication_);
      break;
    }
    // .SMBlob.EmbeddedWindows.Scheme.InitApplicationRes initApplication = 6;
    case kInitApplication: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Message_.initapplication_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SMBlob.EmbeddedWindows.Scheme.Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Message_case()) {
    case kCloseApplication: {
      _this->_internal_mutable_closeapplication()->::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes::MergeFrom(
          from._internal_closeapplication());
      break;
    }
    case kEmbedWindow: {
      _this->_internal_mutable_embedwindow()->::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes::MergeFrom(
          from._internal_embedwindow());
      break;
    }
    case kReleaseWindow: {
      _this->_internal_mutable_releasewindow()->::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes::MergeFrom(
          from._internal_releasewindow());
      break;
    }
    case kCloseWindow: {
      _this->_internal_mutable_closewindow()->::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes::MergeFrom(
          from._internal_closewindow());
      break;
    }
    case kConnectApplication: {
      _this->_internal_mutable_connectapplication()->::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes::MergeFrom(
          from._internal_connectapplication());
      break;
    }
    case kInitApplication: {
      _this->_internal_mutable_initapplication()->::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes::MergeFrom(
          from._internal_initapplication());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SMBlob.EmbeddedWindows.Scheme.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.Message_, other->_impl_.Message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_embedded_2dwindows_2escheme_2eproto_getter, &descriptor_table_embedded_2dwindows_2escheme_2eproto_once,
      file_level_metadata_embedded_2dwindows_2escheme_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Scheme
}  // namespace EmbeddedWindows
}  // namespace SMBlob
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::Window*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::Window >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::Window >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::Status*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::CloseApplicationRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::ConnectApplicationRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::InitApplicationRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::CloseWindowReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::CloseWindowRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::EmbedWindowRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::ReleaseWindowRes >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::Request*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::SMBlob::EmbeddedWindows::Scheme::Response*
Arena::CreateMaybeMessage< ::SMBlob::EmbeddedWindows::Scheme::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SMBlob::EmbeddedWindows::Scheme::Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
